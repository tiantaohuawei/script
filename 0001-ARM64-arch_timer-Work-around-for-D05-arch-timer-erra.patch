From 36f20f53a49a13553df286a4d06fbe94e1ab3212 Mon Sep 17 00:00:00 2001
From: l00431747 <liuzhe24@huawei.com>
Date: Wed, 2 May 2018 10:30:37 -0400
Subject: [PATCH] ARM64: arch_timer: Work around for D05 arch timer errata

Hisi Totem v2 arch timer errata says that the ARM generic timer counter "has the
potential to contain an erroneous value for a small number of core
clock cycles every time the timer value changes".  Accesses to TVAL
(both read and write) are also affected due to the implicit counter
read.  Accesses to CVAL are not affected.

The workaround is to reread TVAL and count registers until successive reads
return the same value, and when writing TVAL to retry until counter
reads before and after the write return the same value.

v2: The original arch_timer_reread function will have 10% chance to read
    again in the loop, the cval_now only have 90% equal to the cval_old,
    it will break the performance, so the best solution is add a limit for
    the difference.

    Also the rewrite_tval had a critical problem, the arch_timer_reg_write tval
    will take 1 or more timer counters, it has no change to break the loop until
    timeout, so add a new solution to fix this problem, the tval will read the cvt
    and add it to set comparevalue, so we only need to make sure the cvalue is
    correct and add a limit for the difference between counter + tval to cvalue.

Signed-off-by: Ding Tianhong <dingtianhong@huwei.com>
Signed-off-by: l00431747 <liuzhe24@huawei.com>
---
 arch/arm64/Kconfig                     |   7 +++
 arch/arm64/include/asm/arch_timer.h    |  40 +++++++++++--
 arch/arm64/include/asm/vdso_datapage.h |   1 +
 arch/arm64/kernel/asm-offsets.c        |   1 +
 arch/arm64/kernel/vdso.c               |   1 +
 arch/arm64/kernel/vdso/gettimeofday.S  |  13 ++++-
 drivers/clocksource/arm_arch_timer.c   | 104 +++++++++++++++++++++++++++++++++
 7 files changed, 162 insertions(+), 5 deletions(-)

diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig
index 871f217..eac535c 100644
--- a/arch/arm64/Kconfig
+++ b/arch/arm64/Kconfig
@@ -401,6 +401,13 @@ config CAVIUM_ERRATUM_23154
 
 	  If unsure, say Y.
 
+config HISI_ERRATUM_161010101
+	bool "Hisilicon Totem v2 timer errata fix"
+	default n
+	help
+	  This option is used to workaround the Hisilicon Totem v2 timer
+	  errata fix.
+
 endmenu
 
 
diff --git a/arch/arm64/include/asm/arch_timer.h b/arch/arm64/include/asm/arch_timer.h
index fbe0ca3..76e0f7d 100644
--- a/arch/arm64/include/asm/arch_timer.h
+++ b/arch/arm64/include/asm/arch_timer.h
@@ -27,6 +27,41 @@
 
 #include <clocksource/arm_arch_timer.h>
 
+
+extern bool arch_timer_read_ool_enabled;
+#ifdef CONFIG_HISI_ERRATUM_161010101
+
+#define ARCH_TIMER_REG_READ(reg, func) \
+extern u64 func##_ool(void); \
+static inline u64 __##func(void) \
+{ \
+	u64 val; \
+	asm volatile("mrs %0, " reg : "=r" (val)); \
+	return val; \
+} \
+static inline u64 _##func(void) \
+{ \
+	if (unlikely(arch_timer_read_ool_enabled)) \
+		return func##_ool(); \
+	else \
+		return __##func(); \
+}
+#else
+#define ARCH_TIMER_REG_READ(reg, func) \
+static inline u64 _##func(void) \
+{ \
+	u64 val; \
+	asm volatile("mrs %0, " reg : "=r" (val)); \
+	return val; \
+}
+#endif
+
+ARCH_TIMER_REG_READ("cntp_tval_el0", arch_timer_get_ptval)
+ARCH_TIMER_REG_READ("cntp_cval_el0", arch_timer_get_pcval)
+ARCH_TIMER_REG_READ("cntv_tval_el0", arch_timer_get_vtval)
+ARCH_TIMER_REG_READ("cntv_cval_el0", arch_timer_get_vcval)
+ARCH_TIMER_REG_READ("cntvct_el0", arch_counter_get_cntvct)
+
 /*
  * These register accessors are marked inline so the compiler can
  * nicely work out which register we want, and chuck away the rest of
@@ -116,12 +151,9 @@ static inline u64 arch_counter_get_cntpct(void)
 
 static inline u64 arch_counter_get_cntvct(void)
 {
-	u64 cval;
-
 	isb();
-	asm volatile("mrs %0, cntvct_el0" : "=r" (cval));
 
-	return cval;
+	return _arch_counter_get_cntvct();
 }
 
 static inline int arch_timer_arch_init(void)
diff --git a/arch/arm64/include/asm/vdso_datapage.h b/arch/arm64/include/asm/vdso_datapage.h
index de66199..da4455a 100644
--- a/arch/arm64/include/asm/vdso_datapage.h
+++ b/arch/arm64/include/asm/vdso_datapage.h
@@ -34,6 +34,7 @@ struct vdso_data {
 	__u32 tz_minuteswest;	/* Whacky timezone stuff */
 	__u32 tz_dsttime;
 	__u32 use_syscall;
+	__u32 timer_reread;     /* Erratum requires two similar timer reads */
 };
 
 #endif /* !__ASSEMBLY__ */
diff --git a/arch/arm64/kernel/asm-offsets.c b/arch/arm64/kernel/asm-offsets.c
index 25de8b2..80e9b78 100644
--- a/arch/arm64/kernel/asm-offsets.c
+++ b/arch/arm64/kernel/asm-offsets.c
@@ -94,6 +94,7 @@ int main(void)
   DEFINE(VDSO_TZ_MINWEST,	offsetof(struct vdso_data, tz_minuteswest));
   DEFINE(VDSO_TZ_DSTTIME,	offsetof(struct vdso_data, tz_dsttime));
   DEFINE(VDSO_USE_SYSCALL,	offsetof(struct vdso_data, use_syscall));
+  DEFINE(VDSO_TIMER_REREAD,    offsetof(struct vdso_data, timer_reread));
   BLANK();
   DEFINE(TVAL_TV_SEC,		offsetof(struct timeval, tv_sec));
   DEFINE(TVAL_TV_USEC,		offsetof(struct timeval, tv_usec));
diff --git a/arch/arm64/kernel/vdso.c b/arch/arm64/kernel/vdso.c
index 97bc68f..f9730b3 100644
--- a/arch/arm64/kernel/vdso.c
+++ b/arch/arm64/kernel/vdso.c
@@ -204,6 +204,7 @@ void update_vsyscall(struct timekeeper *tk)
 	++vdso_data->tb_seq_count;
 	smp_wmb();
 
+	vdso_data->timer_reread			= arch_timer_read_ool_enabled;
 	vdso_data->use_syscall			= use_syscall;
 	vdso_data->xtime_coarse_sec		= tk->xtime_sec;
 	vdso_data->xtime_coarse_nsec		= tk->tkr_mono.xtime_nsec >>
diff --git a/arch/arm64/kernel/vdso/gettimeofday.S b/arch/arm64/kernel/vdso/gettimeofday.S
index efa79e8..6580e96 100644
--- a/arch/arm64/kernel/vdso/gettimeofday.S
+++ b/arch/arm64/kernel/vdso/gettimeofday.S
@@ -207,7 +207,7 @@ ENDPROC(__kernel_clock_getres)
 /*
  * Read the current time from the architected counter.
  * Expects vdso_data to be initialised.
- * Clobbers the temporary registers (x9 - x15).
+ * Clobbers the temporary registers (x9 - x17).
  * Returns:
  *  - w9		= vDSO sequence counter
  *  - (x10, x11)	= (ts->tv_sec, shifted ts->tv_nsec)
@@ -217,6 +217,7 @@ ENTRY(__do_get_tspec)
 	.cfi_startproc
 
 	/* Read from the vDSO data page. */
+	ldr	w17, [vdso_data, #VDSO_TIMER_REREAD]
 	ldr	x10, [vdso_data, #VDSO_CS_CYCLE_LAST]
 	ldp	x13, x14, [vdso_data, #VDSO_XTIME_CLK_SEC]
 	ldp	w11, w12, [vdso_data, #VDSO_CS_MULT]
@@ -226,6 +227,16 @@ ENTRY(__do_get_tspec)
 	isb
 	mrs	x15, cntvct_el0
 
+	cmp	w17, #0
+	b.eq	2f
+1:
+	mov	x3, x15
+	isb
+	mrs	x15, cntvct_el0
+	sub	x3, x15, x3
+	lsr	x3, x3, #2
+	cbnz	x3, 1b
+2:
 	/* Calculate cycle delta and convert to ns. */
 	sub	x10, x15, x10
 	/* We can only guarantee 56 bits of precision. */
diff --git a/drivers/clocksource/arm_arch_timer.c b/drivers/clocksource/arm_arch_timer.c
index c64d543..6ef4e20 100644
--- a/drivers/clocksource/arm_arch_timer.c
+++ b/drivers/clocksource/arm_arch_timer.c
@@ -75,6 +75,51 @@ static bool arch_timer_mem_use_virtual;
  * Architected system timer support.
  */
 
+
+bool arch_timer_read_ool_enabled = false;
+EXPORT_SYMBOL(arch_timer_read_ool_enabled);
+#ifdef CONFIG_HISI_ERRATUM_161010101
+
+/*
+ * __always_inline is used to ensure that func() is not an actual function
+ * pointer, which would result in the register accesses potentially being too
+ * far apart for the loop to work.
+ */
+static __always_inline u64 arch_timer_reread(u64 (*func)(void))
+{
+	u64 cval_old, cval_new;
+	int timeout = 200;
+
+	do {
+		isb();
+		cval_old = func();
+		cval_new = func();
+		timeout--;
+	} while (((cval_new - cval_old) >> 2) && timeout);
+
+	WARN_ON_ONCE(!timeout);
+
+	return cval_new;
+}
+
+u64 notrace arch_counter_get_cntvct_ool(void)
+{
+	return arch_timer_reread(__arch_counter_get_cntvct);
+}
+EXPORT_SYMBOL(arch_counter_get_cntvct_ool);
+
+u64 arch_timer_get_vtval_ool(void)
+{
+	return arch_timer_reread(__arch_timer_get_vtval);
+}
+
+u64 arch_timer_get_ptval_ool(void)
+{
+	return arch_timer_reread(__arch_timer_get_ptval);
+}
+
+#endif /* CONFIG_HISI_ERRATUM_TOTEM_V2 */
+
 static __always_inline
 void arch_timer_reg_write(int access, enum arch_timer_reg reg, u32 val,
 			  struct clock_event_device *clk)
@@ -224,6 +269,50 @@ static __always_inline void set_next_event(const int access, unsigned long evt,
 	arch_timer_reg_write(access, ARCH_TIMER_REG_CTRL, ctrl, clk);
 }
 
+#ifdef CONFIG_HISI_ERRATUM_161010101
+static __always_inline void rewrite_tval(const int access,
+		unsigned long evt, struct clock_event_device *clk)
+{
+	u64 cval_old, cval_new;
+	int timeout = 200;
+
+	do {
+		arch_timer_reg_write(access, ARCH_TIMER_REG_TVAL, evt, clk);
+		cval_old = __arch_timer_get_pcval();
+		cval_new = __arch_counter_get_cntvct() + evt;
+		timeout--;
+	} while ((cval_new - cval_old) >> 3 && timeout);
+
+	WARN_ON_ONCE(!timeout);
+}
+
+static __always_inline void set_next_event_errata(const int access,
+		unsigned long evt, struct clock_event_device *clk)
+{
+	unsigned long ctrl;
+
+	ctrl = arch_timer_reg_read(access, ARCH_TIMER_REG_CTRL, clk);
+	ctrl |= ARCH_TIMER_CTRL_ENABLE;
+	ctrl &= ~ARCH_TIMER_CTRL_IT_MASK;
+	rewrite_tval(access, evt, clk);
+	arch_timer_reg_write(access, ARCH_TIMER_REG_CTRL, ctrl, clk);
+}
+
+static int arch_timer_set_next_event_virt_errata(unsigned long evt,
+						 struct clock_event_device *clk)
+{
+	set_next_event_errata(ARCH_TIMER_VIRT_ACCESS, evt, clk);
+	return 0;
+}
+
+static int arch_timer_set_next_event_phys_errata(unsigned long evt,
+						 struct clock_event_device *clk)
+{
+	set_next_event_errata(ARCH_TIMER_PHYS_ACCESS, evt, clk);
+	return 0;
+}
+#endif /* CONFIG_HISI_ERRATUM_TOTEM_V2 */
+
 static int arch_timer_set_next_event_virt(unsigned long evt,
 					  struct clock_event_device *clk)
 {
@@ -267,10 +356,20 @@ static void __arch_timer_setup(unsigned type,
 			clk->irq = arch_timer_ppi[VIRT_PPI];
 			clk->set_state_shutdown = arch_timer_shutdown_virt;
 			clk->set_next_event = arch_timer_set_next_event_virt;
+#ifdef CONFIG_HISI_ERRATUM_161010101
+			if (unlikely(arch_timer_read_ool_enabled))
+				clk->set_next_event =
+					arch_timer_set_next_event_virt_errata;
+#endif
 		} else {
 			clk->irq = arch_timer_ppi[PHYS_SECURE_PPI];
 			clk->set_state_shutdown = arch_timer_shutdown_phys;
 			clk->set_next_event = arch_timer_set_next_event_phys;
+#ifdef CONFIG_HISI_ERRATUM_161010101
+			if (unlikely(arch_timer_read_ool_enabled))
+				clk->set_next_event =
+					arch_timer_set_next_event_phys_errata;
+#endif
 		}
 	} else {
 		clk->features |= CLOCK_EVT_FEAT_DYNIRQ;
@@ -729,6 +828,11 @@ static void __init arch_timer_of_init(struct device_node *np)
 
 	arch_timer_c3stop = !of_property_read_bool(np, "always-on");
 
+#ifdef CONFIG_HISI_ERRATUM_161010101
+	if (of_property_read_bool(np, "hisi,erratum-totem-v2"))
+		arch_timer_read_ool_enabled = true;
+#endif
+	/*
 	/*
 	 * If we cannot rely on firmware initializing the timer registers then
 	 * we should use the physical timers instead.
-- 
1.8.3.1


